global
    log stdout format short local0 notice
    daemon
    uid 100
    gid 101
    # CRUCIAL: Necesario para que el Rate Limiting funcione
    #stats socket /var/run/haproxy/admin.sock mode 660 level admin 
    stats socket /tmp/admin.sock mode 660 level admin
    maxconn 4000


defaults
    mode http
    log global
    timeout connect 5s
    timeout client 50s
    timeout server 50s
    # 1. Definición de la tabla para Rate Limiting: 
    # Almacena hasta 100,000 IPs, expira entradas en 30s, guarda la tasa de peticiones en 10s.



# ------------------------------------------------
# Backend 1: Tu Aplicación Backend (API)
# ------------------------------------------------

backend app_backend
    http-response set-header Access-Control-Allow-Origin "http://localhost:4000"
    #http-response set-header Access-Control-Allow-Origin "http://192.168.0.12:4000"
    #http-response set-header Access-Control-Allow-Origin "https://192.168.0.17"
    http-response set-header Access-Control-Allow-Methods "GET, POST, OPTIONS, PUT, DELETE"
    http-response set-header Access-Control-Allow-Headers "Content-Type, X-Requested-With, Authorization"
    http-response set-header Access-Control-Allow-Credentials true
    http-response set-header Access-Control-Expose-Headers "Authorization" # Opcional: si expones headers al frontend
    http-response set-header Cross-Origin-Opener-Policy same-origin-allow-popups
    balance roundrobin
    server web_backend 192.168.0.12:8080 check




# ------------------------------------------------
# Backend 2: Frontend (Archivos estáticos/JS)
# ------------------------------------------------
backend app_frontend
    http-response set-header Access-Control-Allow-Origin "http://localhost:4000"
    #http-response set-header Access-Control-Allow-Origin "http://192.168.0.12:4000"
    #http-response set-header Access-Control-Allow-Origin "https://192.168.0.17"
    http-response set-header Access-Control-Allow-Methods "GET, POST, OPTIONS, PUT, DELETE"
    http-response set-header Cross-Origin-Opener-Policy same-origin-allow-popups
    http-response set-header Access-Control-Allow-Headers "Content-Type, X-Requested-With, Authorization"
    http-response set-header Access-Control-Allow-Credentials true
    balance roundrobin
    server web_frontend 192.168.0.12:4000 check


# ------------------------------------------------
# Backend 3: WAF Coraza
# ------------------------------------------------
backend coraza_spoa
    mode tcp
    # El nombre del servidor es el nombre del servicio en docker-compose, network HOST -> 127.0.0.1 (localhost) en lugar
    server coraza_server 127.0.0.1:9000 check inter 10s


# ------------------------------------------------
# Backend 4: CORS PREFLIGHT (Manejo de OPTIONS)
# ------------------------------------------------
backend cors_options
    mode http
    
    # 1. Especificar el origen permitido (Tu frontend)
    http-response set-header Access-Control-Allow-Origin "http://localhost:4000"
    #http-response set-header Access-Control-Allow-Origin "http://192.168.0.12:4000"
    #http-response set-header Access-Control-Allow-Origin "https://192.168.0.17"
    http-response set-header Cross-Origin-Opener-Policy same-origin-allow-popups
    # 2. Métodos permitidos para el recurso real
    http-response set-header Access-Control-Allow-Methods "GET, POST, OPTIONS, PUT, DELETE"
    http-response set-header Access-Control-Allow-Credentials true
    # 3. Headers permitidos que el cliente puede enviar
    http-response set-header Access-Control-Allow-Headers "Content-Type, X-Requested-With, Authorization"
    
    # 4. Tiempo que el navegador puede almacenar en caché la respuesta OPTIONS
    http-response set-header Access-Control-Max-Age "3600"
    
    # 5. ¡DETENER y responder con ÉXITO!
    http-request deny status 200

# ------------------------------------------------
# FRONTEND PRINCIPAL (HTTPS)
# ------------------------------------------------
frontend entrada_publica_https
    bind *:443 ssl crt /usr/local/etc/haproxy/ssl/certificado.pem 
    mode http
    stick-table type ip size 100k expire 30s store http_req_rate(10s)
    #http-response set-header Access-Control-Allow-Origin "https://miservicioweb.com"
    
    
    #acl is_google_auth path_beg /usuarios/google-auth
    #http-response set-header Access-Control-Allow-Origin "*" if is_google_auth
    
    acl is_backend path_beg /productos /usuarios /favoritos /resenas /caracteristicas /categorias /pagos /auth /email /direcciones /pedidos
    #acl is_options method OPTIONS
    #use_backend cors_options if is_options
    
    # 1: Control de Host Header Injection
    acl valid_host hdr(host) -i 192.168.0.12 192.168.0.17 localhost 127.0.0.1
    #acl valid_host hdr(host) -i dominio.com
    http-request deny deny_status 400 if !valid_host

    # 2: Rate Limiting (DOS/DDOS)
    #http-request track-sc0 src 
    # Deniega (429 Too Many Requests) si la tasa de peticiones es mayor a 10 en 10s
    #http-request deny deny_status 429 if { sc_http_req_rate(0) gt 100 }

    # 3: Encabezados X-Forwarded (CRUCIAL)
    # Le dice a tu backend/frontend que la petición fue HTTPS.
    http-request set-header X-Forwarded-Proto https
    # Envía la IP real del cliente (Necesario si usas Rate Limiting o logs basados en IP)
    http-request set-header X-Forwarded-For %[src]
    
    
    # --- Integración de Coraza SPOA (Aquí va el filtro WAF) ---
    filter spoe engine coraza_waf_engine config /usr/local/etc/haproxy/coraza.cfg
    # ... (Reglas de bloqueo de Coraza) ...
    http-request deny deny_status 403 if { var(txn.coraza.action) -m str deny }
    http-response deny deny_status 403 if { var(txn.coraza.action) -m str deny }
    http-request deny deny_status 504 if { var(txn.coraza.error) -m int gt 0 }

    # --- Lógica de Ruteo ---
    # Notar que la comunicación con 192.168.0.12 es HTTP
    
    use_backend app_backend if is_backend
    use_backend app_frontend if { path_beg / }

# Frontend: HTTP Redirect (Opcional)
frontend entrada_publica_http_redirect
    bind *:80
    mode http
    redirect scheme https code 301 if !{ ssl_fc }
